# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Display the version of or-tools that the package links to
#' 
#' Useful for data analysis provenance.
#' 
#' @export
orToolsVersion <- function() {
    .Call('_RcppORtools_orToolsVersion', PACKAGE = 'RcppORtools')
}

#' R binding to the powerful GLOP linear solver
#' 
#' The primary OR-Tools linear optimization solver is Glop, Google's linear programming system. It's fast, memory efficient, and numerically stable.
#' 
#' This function provides a binding via Rcpp to the linear solver.
#' 
#' @param objectiveCoefs A *named* numeric vector representing the objective coefficients (the c vector). The names are essential as GLOP insists on named variables.
#' @param constraintMat  A numeric matrix of constraint coefficients. (the A matrix)
#' @param constraintRHS A vector of inequality right-hand sides (the b vector)
#' @param maximise Logical giving the direction of the optimization. TRUE means that the objective is to maximize the objective function, FALSE (default) means to minimize it.
#' 
#' @return solution A named list of:
#'            'optimum' - value of the objective funtion
#'            'solution' - a vector of equal length to objectiveCoefs, detailing the solution
#'            'wall_time_ms' - time taken by solved
#'            'is_optimal -  status flag provided by the solver
#'            'is_feasible' -  status flag provided by the solver (if this is false, then the solver might not be able to solve the problem at all!)
#' 
#' @references \url{https://developers.google.com/optimization/lp/glop}
#' @references \url{https://en.wikipedia.org/wiki/Linear_programming}
#' 
#' @examples
#' library(data.table)
#' data(StiglerDiet)
#' 
#' costVec <- rep(1, length(StiglerDiet$foodAvailable$Commodity)) # everything will be per dollar spent, so the cvec is all 1's
#' names(costVec) <- StiglerDiet$foodAvailable$Commodity # Name the variables
#' 
#' #Nutrient data is in amount per dollar
#' constraintMat <- StiglerDiet$foodAvailable[,as.matrix(.SD) ,
#'                     .SDcols = !c("Commodity","Price1939","Weight","Weight_unit","Weight_value")]
#'                                    
#' row.names(constraintMat) <- StiglerDiet$foodAvailable$Commodity
#' 
#' objectiveVec <- StiglerDiet$nutrientRDA$RDI_value
#' names(objectiveVec) <- StiglerDiet$nutrientRDA$Nutrient
#' 
#' glopt <- glop_lp(
#'             objectiveCoefs = costVec,
#'             constraintMat = t(constraintMat[names(costVec),]),
#'             constraintRHS = objectiveVec[colnames(constraintMat)])
#' 
#' 
#' glopt$solution[glopt$solution > 0]
#' 
#' @export
glop_lp <- function(objectiveCoefs, constraintMat, constraintRHS, maximise = FALSE) {
    .Call('_RcppORtools_glop_lp', PACKAGE = 'RcppORtools', objectiveCoefs, constraintMat, constraintRHS, maximise)
}

reflectMatrixToVecVec <- function(mat2convert) {
    .Call('_RcppORtools_reflectMatrixToVecVec', PACKAGE = 'RcppORtools', mat2convert)
}

#' A simple TSP solver
#'
#' Givent a matrix of pairwise distances, compute a travelling salesman problem solution that visits each
#' location once and only once before returning to the start.
#' 
#' @param distance_matrix All-vs-all distances between cities
#' @param startIndex The integer label of the city in which to start
#' 
#' @return solution A named list of:
#'            'route' - The sequence of cities in which to travel to minimise the distance travelled overall (first and last cities are always the same of course)
#'            'wall_time_ms' - time taken for solver in ms
#'            'objective_dsitance' - total distance travelled
#' 
#' @examples
#' distMatrix <- matrix(c(
#' 0, 2451, 713, 1018, 1631, 1374, 2408, 213, 2571, 875, 1420, 2145, 1972,
#' 2451, 0, 1745, 1524, 831, 1240, 959, 2596, 403, 1589, 1374, 357, 579,
#' 713, 1745, 0, 355, 920, 803, 1737, 851, 1858, 262, 940, 1453, 1260,
#' 1018, 1524, 355, 0, 700, 862, 1395, 1123, 1584, 466, 1056, 1280, 987,
#' 1631, 831, 920, 700, 0, 663, 1021, 1769, 949, 796, 879, 586, 371,
#' 1374, 1240, 803, 862, 663, 0, 1681, 1551, 1765, 547, 225, 887, 999,
#' 2408, 959, 1737, 1395, 1021, 1681, 0, 2493, 678, 1724, 1891, 1114, 701,
#' 213, 2596, 851, 1123, 1769, 1551, 2493, 0, 2699, 1038, 1605, 2300, 2099,
#' 2571, 403, 1858, 1584, 949, 1765, 678, 2699, 0, 1744, 1645, 653, 600,
#' 875, 1589, 262, 466, 796, 547, 1724, 1038, 1744, 0, 679, 1272, 1162,
#' 1420, 1374, 940, 1056, 879, 225, 1891, 1605, 1645, 679, 0, 1017, 1200,
#' 2145, 357, 1453, 1280, 586, 887, 1114, 2300, 653, 1272, 1017, 0, 504,
#' 1972, 579, 1260, 987, 371, 999, 701, 2099, 600, 1162, 1200, 504, 0), nrow = 13, byrow = TRUE)
#' 
#' singleVisitorTSP(distMatrix, 3)
#' 
#' @export
singleVisitorTSP <- function(distance_matrix, startIndex = 1L) {
    .Call('_RcppORtools_singleVisitorTSP', PACKAGE = 'RcppORtools', distance_matrix, startIndex)
}

#' A simple knapsack solver
#' 
#' Solve knapsack proble via google's brilliant OR tools lbirary.
#' 
#' @param profits A vector of integer item profits (must be equal in length to ncol(weights))
#' @param weights A matrix (which can have a single row if one is only interested in the standard knapsack problem) of item weights
#' @param capacities A vector of length nrow(weights) of knapsack capacities
#' 
#' @return solution A named list of:
#'            'packed_items' - the 1-based indicies of items selected for packing
#'            'total_profit' - the optimised sum of profits
#'            'is_optimal' - a status flag provided by the solver
#' @references \url{https://developers.google.com/optimization/reference/algorithms/knapsack_solver/}
#' @references \url{https://en.wikipedia.org/wiki/Knapsack_problem}
#' 
#' @examples
#' # Taken from the OR-tools documentation examples:
#' 
#' SKPProfits <- c(360, 83, 59,  130, 431, 67, 230, 52,  93,  125, 670, 892, 600,
#'                     38,  48, 147, 78,  256, 63, 17,  120, 164, 432, 35,  92,  110,
#'                     22,  42, 50,  323, 514, 28, 87,  73,  78,  15,  26,  78,  210,
#'                     36,  85, 189, 274, 43,  33, 10,  19,  389, 276, 312)
#'                     
#' SKPWeights <- matrix(nrow = 1,
#'                   c(7,  0,  30, 22, 80, 94, 11, 81, 70, 64, 59, 18, 0,  36, 3,  8,  15,
#'                     42, 9,  0,  42, 47, 52, 32, 26, 48, 55, 6,  29, 84, 2,  4,  18, 56,
#'                     7,  29, 93, 44, 71, 3,  86, 66, 31, 65, 0,  79, 20, 65, 52, 13) )
#'                     
#'                     
#' SKPCapacities <- c(850)
#' 
#'  
#' SKPsolution <- solveMultiKnapsackProblem(SKPProfits, SKPWeights, SKPCapacities)
#' 
#' sum(SKPProfits[SKPsolution$packed_items]) # same as 'total_profit'
#' SKPWeights[SKPsolution$packed_items] # Items packed
#' sum(SKPWeights[SKPsolution$packed_items]) # Capacities used
#' 
#' 
#' #Example taken from ORtools docs
#' MKPprofits <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
#' MKPweights <- matrix(c(c(1, 2, 3, 4, 5, 6, 7, 8, 9),
#'                    c(1, 1, 1, 1, 1, 1, 1, 1, 1)),
#'                    nrow = 2, byrow = TRUE)
#' 
#' MKPcapacities <- c(34,4)
#' 
#' 
#' MKPsoolution <- solveMultiKnapsackProblem(MKPprofits, MKPweights, MKPcapacities)
#' MKPsoolution
#' 
#' sum(MKPprofits[MKPsoolution$packed_items]) # same as 'total_profit'
#' MKPweights[,MKPsoolution$packed_items] # Items packed
#' rowSums(MKPweights[,MKPsoolution$packed_items]) # Capacities used
#' 
#' @export
solveMultiKnapsackProblem <- function(profits, weights, capacities) {
    .Call('_RcppORtools_solveMultiKnapsackProblem', PACKAGE = 'RcppORtools', profits, weights, capacities)
}

